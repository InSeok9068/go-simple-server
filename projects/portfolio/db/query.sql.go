// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
)

const countCategories = `-- name: CountCategories :one
SELECT COUNT(1)
FROM category
WHERE uid = ?
`

func (q *Queries) CountCategories(ctx context.Context, uid string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCategories, uid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAccount = `-- name: CreateAccount :exec
INSERT INTO account (uid, category_id, name, provider, balance, monthly_contrib, note)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateAccountParams struct {
	Uid            string
	CategoryID     string
	Name           string
	Provider       string
	Balance        int64
	MonthlyContrib int64
	Note           string
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) error {
	_, err := q.db.ExecContext(ctx, createAccount,
		arg.Uid,
		arg.CategoryID,
		arg.Name,
		arg.Provider,
		arg.Balance,
		arg.MonthlyContrib,
		arg.Note,
	)
	return err
}

const createAllocationTarget = `-- name: CreateAllocationTarget :exec
INSERT INTO allocation_target (uid, category_id, target_weight, target_amount, note)
VALUES (?, ?, ?, ?, ?)
`

type CreateAllocationTargetParams struct {
	Uid          string
	CategoryID   string
	TargetWeight float64
	TargetAmount int64
	Note         string
}

func (q *Queries) CreateAllocationTarget(ctx context.Context, arg CreateAllocationTargetParams) error {
	_, err := q.db.ExecContext(ctx, createAllocationTarget,
		arg.Uid,
		arg.CategoryID,
		arg.TargetWeight,
		arg.TargetAmount,
		arg.Note,
	)
	return err
}

const createBudgetEntry = `-- name: CreateBudgetEntry :exec
INSERT INTO budget_entry (uid, name, direction, class, planned, actual, note)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateBudgetEntryParams struct {
	Uid       string
	Name      string
	Direction string
	Class     string
	Planned   int64
	Actual    int64
	Note      string
}

func (q *Queries) CreateBudgetEntry(ctx context.Context, arg CreateBudgetEntryParams) error {
	_, err := q.db.ExecContext(ctx, createBudgetEntry,
		arg.Uid,
		arg.Name,
		arg.Direction,
		arg.Class,
		arg.Planned,
		arg.Actual,
		arg.Note,
	)
	return err
}

const createCategory = `-- name: CreateCategory :exec
INSERT INTO category (uid, name, role, parent_id, display_order)
VALUES (?, ?, ?, ?, ?)
`

type CreateCategoryParams struct {
	Uid          string
	Name         string
	Role         string
	ParentID     sql.NullString
	DisplayOrder int64
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) error {
	_, err := q.db.ExecContext(ctx, createCategory,
		arg.Uid,
		arg.Name,
		arg.Role,
		arg.ParentID,
		arg.DisplayOrder,
	)
	return err
}

const createContributionPlan = `-- name: CreateContributionPlan :exec
INSERT INTO contribution_plan (uid, security_id, weight, amount, note)
VALUES (?, ?, ?, ?, ?)
`

type CreateContributionPlanParams struct {
	Uid        string
	SecurityID string
	Weight     float64
	Amount     int64
	Note       string
}

func (q *Queries) CreateContributionPlan(ctx context.Context, arg CreateContributionPlanParams) error {
	_, err := q.db.ExecContext(ctx, createContributionPlan,
		arg.Uid,
		arg.SecurityID,
		arg.Weight,
		arg.Amount,
		arg.Note,
	)
	return err
}

const createHolding = `-- name: CreateHolding :exec
INSERT INTO holding (uid, security_id, amount, target_amount, note)
VALUES (?, ?, ?, ?, ?)
`

type CreateHoldingParams struct {
	Uid          string
	SecurityID   string
	Amount       int64
	TargetAmount int64
	Note         string
}

func (q *Queries) CreateHolding(ctx context.Context, arg CreateHoldingParams) error {
	_, err := q.db.ExecContext(ctx, createHolding,
		arg.Uid,
		arg.SecurityID,
		arg.Amount,
		arg.TargetAmount,
		arg.Note,
	)
	return err
}

const createSecurity = `-- name: CreateSecurity :exec
INSERT INTO security (uid, symbol, name, type, category_id, currency, note)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateSecurityParams struct {
	Uid        string
	Symbol     string
	Name       string
	Type       string
	CategoryID sql.NullString
	Currency   string
	Note       string
}

func (q *Queries) CreateSecurity(ctx context.Context, arg CreateSecurityParams) error {
	_, err := q.db.ExecContext(ctx, createSecurity,
		arg.Uid,
		arg.Symbol,
		arg.Name,
		arg.Type,
		arg.CategoryID,
		arg.Currency,
		arg.Note,
	)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO user (uid, name, email) VALUES (?, ?, ?)
`

type CreateUserParams struct {
	Uid   string
	Name  string
	Email string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser, arg.Uid, arg.Name, arg.Email)
	return err
}

const getTotalAsset = `-- name: GetTotalAsset :one
SELECT uid, total_amount
FROM v_total_asset
WHERE uid = ?
`

func (q *Queries) GetTotalAsset(ctx context.Context, uid string) (VTotalAsset, error) {
	row := q.db.QueryRowContext(ctx, getTotalAsset, uid)
	var i VTotalAsset
	err := row.Scan(&i.Uid, &i.TotalAmount)
	return i, err
}

const getUser = `-- name: GetUser :one

SELECT uid, name, email, created, updated FROM user WHERE uid = ? LIMIT 1
`

// sqlc generate -f ./projects/portfolio/sqlc.yaml
func (q *Queries) GetUser(ctx context.Context, uid string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, uid)
	var i User
	err := row.Scan(
		&i.Uid,
		&i.Name,
		&i.Email,
		&i.Created,
		&i.Updated,
	)
	return i, err
}

const listAccounts = `-- name: ListAccounts :many
SELECT
    a.id,
    a.uid,
    a.category_id,
    a.name,
    a.provider,
    a.balance,
    a.monthly_contrib,
    a.note,
    c.name AS category_name
FROM account a
JOIN category c ON c.id = a.category_id
WHERE a.uid = ?
ORDER BY c.display_order, a.name
`

type ListAccountsRow struct {
	ID             string
	Uid            string
	CategoryID     string
	Name           string
	Provider       string
	Balance        int64
	MonthlyContrib int64
	Note           string
	CategoryName   string
}

func (q *Queries) ListAccounts(ctx context.Context, uid string) ([]ListAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAccounts, uid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountsRow
	for rows.Next() {
		var i ListAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.CategoryID,
			&i.Name,
			&i.Provider,
			&i.Balance,
			&i.MonthlyContrib,
			&i.Note,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllocationTargets = `-- name: ListAllocationTargets :many
SELECT
    a.id,
    a.uid,
    a.category_id,
    a.target_weight,
    a.target_amount,
    a.note,
    c.name AS category_name
FROM allocation_target a
JOIN category c ON c.id = a.category_id
WHERE a.uid = ?
ORDER BY c.display_order
`

type ListAllocationTargetsRow struct {
	ID           string
	Uid          string
	CategoryID   string
	TargetWeight float64
	TargetAmount int64
	Note         string
	CategoryName string
}

func (q *Queries) ListAllocationTargets(ctx context.Context, uid string) ([]ListAllocationTargetsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllocationTargets, uid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllocationTargetsRow
	for rows.Next() {
		var i ListAllocationTargetsRow
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.CategoryID,
			&i.TargetWeight,
			&i.TargetAmount,
			&i.Note,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBudgetEntries = `-- name: ListBudgetEntries :many
SELECT
    id,
    uid,
    name,
    direction,
    class,
    planned,
    actual,
    note
FROM budget_entry
WHERE uid = ?
ORDER BY
    CASE direction WHEN 'income' THEN 0 ELSE 1 END,
    CASE class WHEN 'fixed' THEN 0 ELSE 1 END,
    name
`

type ListBudgetEntriesRow struct {
	ID        string
	Uid       string
	Name      string
	Direction string
	Class     string
	Planned   int64
	Actual    int64
	Note      string
}

func (q *Queries) ListBudgetEntries(ctx context.Context, uid string) ([]ListBudgetEntriesRow, error) {
	rows, err := q.db.QueryContext(ctx, listBudgetEntries, uid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBudgetEntriesRow
	for rows.Next() {
		var i ListBudgetEntriesRow
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.Name,
			&i.Direction,
			&i.Class,
			&i.Planned,
			&i.Actual,
			&i.Note,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategories = `-- name: ListCategories :many
SELECT
    id,
    uid,
    name,
    role,
    parent_id,
    display_order
FROM category
WHERE uid = ?
ORDER BY display_order, name
`

func (q *Queries) ListCategories(ctx context.Context, uid string) ([]Category, error) {
	rows, err := q.db.QueryContext(ctx, listCategories, uid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.Name,
			&i.Role,
			&i.ParentID,
			&i.DisplayOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCategoryAllocations = `-- name: ListCategoryAllocations :many
SELECT v.uid, v.category_id, v.category_name, v.amount, v.weight_pct
FROM v_category_allocation v
JOIN category c ON c.id = v.category_id AND c.uid = v.uid
WHERE v.uid = ?
ORDER BY c.display_order
`

func (q *Queries) ListCategoryAllocations(ctx context.Context, uid string) ([]VCategoryAllocation, error) {
	rows, err := q.db.QueryContext(ctx, listCategoryAllocations, uid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VCategoryAllocation
	for rows.Next() {
		var i VCategoryAllocation
		if err := rows.Scan(
			&i.Uid,
			&i.CategoryID,
			&i.CategoryName,
			&i.Amount,
			&i.WeightPct,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContributionPlans = `-- name: ListContributionPlans :many
SELECT
    cp.id,
    cp.uid,
    cp.security_id,
    cp.weight,
    cp.amount,
    cp.note,
    s.symbol AS security_symbol,
    s.name AS security_name,
    s.category_id AS security_category_id,
    c.name AS category_name
FROM contribution_plan cp
JOIN security s ON s.id = cp.security_id
LEFT JOIN category c ON c.id = s.category_id
WHERE cp.uid = ?
ORDER BY cp.weight DESC, s.name
`

type ListContributionPlansRow struct {
	ID                 string
	Uid                string
	SecurityID         string
	Weight             float64
	Amount             int64
	Note               string
	SecuritySymbol     string
	SecurityName       string
	SecurityCategoryID sql.NullString
	CategoryName       sql.NullString
}

func (q *Queries) ListContributionPlans(ctx context.Context, uid string) ([]ListContributionPlansRow, error) {
	rows, err := q.db.QueryContext(ctx, listContributionPlans, uid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContributionPlansRow
	for rows.Next() {
		var i ListContributionPlansRow
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.SecurityID,
			&i.Weight,
			&i.Amount,
			&i.Note,
			&i.SecuritySymbol,
			&i.SecurityName,
			&i.SecurityCategoryID,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHoldings = `-- name: ListHoldings :many
SELECT
    h.id,
    h.uid,
    h.security_id,
    h.amount,
    h.target_amount,
    h.note,
    s.symbol AS security_symbol,
    s.name AS security_name,
    s.type AS security_type,
    s.category_id AS security_category_id,
    c.name AS category_name,
    s.currency AS security_currency
FROM holding h
JOIN security s ON s.id = h.security_id
LEFT JOIN category c ON c.id = s.category_id
WHERE h.uid = ?
ORDER BY c.display_order, s.name
`

type ListHoldingsRow struct {
	ID                 string
	Uid                string
	SecurityID         string
	Amount             int64
	TargetAmount       int64
	Note               string
	SecuritySymbol     string
	SecurityName       string
	SecurityType       string
	SecurityCategoryID sql.NullString
	CategoryName       sql.NullString
	SecurityCurrency   string
}

func (q *Queries) ListHoldings(ctx context.Context, uid string) ([]ListHoldingsRow, error) {
	rows, err := q.db.QueryContext(ctx, listHoldings, uid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListHoldingsRow
	for rows.Next() {
		var i ListHoldingsRow
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.SecurityID,
			&i.Amount,
			&i.TargetAmount,
			&i.Note,
			&i.SecuritySymbol,
			&i.SecurityName,
			&i.SecurityType,
			&i.SecurityCategoryID,
			&i.CategoryName,
			&i.SecurityCurrency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRebalanceGaps = `-- name: ListRebalanceGaps :many
SELECT
    g.uid,
    g.category_id,
    c.name AS category_name,
    g.target_weight,
    g.target_amount,
    g.current_amount,
    g.target_by_weight,
    g.target_final,
    g.gap_amount
FROM v_rebalance_gap g
JOIN category c ON c.id = g.category_id
WHERE g.uid = ?
ORDER BY c.display_order
`

type ListRebalanceGapsRow struct {
	Uid            string
	CategoryID     string
	CategoryName   string
	TargetWeight   float64
	TargetAmount   int64
	CurrentAmount  interface{}
	TargetByWeight float64
	TargetFinal    interface{}
	GapAmount      int64
}

func (q *Queries) ListRebalanceGaps(ctx context.Context, uid string) ([]ListRebalanceGapsRow, error) {
	rows, err := q.db.QueryContext(ctx, listRebalanceGaps, uid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRebalanceGapsRow
	for rows.Next() {
		var i ListRebalanceGapsRow
		if err := rows.Scan(
			&i.Uid,
			&i.CategoryID,
			&i.CategoryName,
			&i.TargetWeight,
			&i.TargetAmount,
			&i.CurrentAmount,
			&i.TargetByWeight,
			&i.TargetFinal,
			&i.GapAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSecurities = `-- name: ListSecurities :many
SELECT
    id,
    uid,
    symbol,
    name,
    type,
    category_id,
    currency,
    note
FROM security
WHERE uid = ?
ORDER BY name
`

func (q *Queries) ListSecurities(ctx context.Context, uid string) ([]Security, error) {
	rows, err := q.db.QueryContext(ctx, listSecurities, uid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Security
	for rows.Next() {
		var i Security
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.Symbol,
			&i.Name,
			&i.Type,
			&i.CategoryID,
			&i.Currency,
			&i.Note,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
