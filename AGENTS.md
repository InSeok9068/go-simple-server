## 공통

1.  한글로 대답해줘.
2.  불필요한 복잡성보다는 직관적이고 명확한 코드를 선호해.
3.  충분히 공통 요소가 많이 보이고, 공통화가 명확히 유리한 시점에 리팩토링을 진행해.

## 프로젝트 구성

- **언어**: Go
- **서버 프레임워크**: Echo
- **템플릿 라이브러리**: Gomponents
- **데이터베이스**: SQLite
- **데이터베이스 마이그레이션**: Goose
- **SQL 코드 제너레이터**: SQLC
- **프론트엔드 라이브러리**: HTMX, Alpine.js
- **CSS 프레임워크**: BeerCSS (기본), TailwindCSS (일부 프로젝트)
- **소스 관리**: Monorepo (여러 프로젝트를 한 저장소에서 관리)

## 프론트엔드 라이브러리 역할 정의

- **HTMX**
  - 주요 역할: 서버와의 AJAX 통신을 통해 HTML 응답을 받아 현재 페이지의 특정 부분을 동적으로 업데이트.
  - 사용 목적: 페이지 전체를 새로고침하지 않고, 사용자 인터랙션에 따라 서버로부터 새로운 HTML 조각(partial)을 가져와 UI를 갱신하여 SPA(Single Page Application)와 유사한 사용자 경험을 제공.
- **Alpine.js**
  - 주요 역할: 클라이언트 사이드의 가볍고 반응적인 인터랙션을 처리.
  - 사용 목적: HTML 마크업 내에서 직접 UI 요소의 상태(state)를 관리하고, 해당 상태 변화에 따른 동적인 동작 (예: 드롭다운 메뉴, 탭 전환, 모달 창 표시/숨김 등)을 구현.

## 폴더 구조

- `cmd/{프로젝트명}/main.go`: 해당 프로젝트의 서버 실행 파일 (entrypoint).
- `projects/{프로젝트명}/`: 해당 프로젝트의 소스 코드.
  - `handlers`: HTTP 요청을 처리하는 핸들러.
  - `views`: `Gomponents`를 사용하여 HTML 뷰를 생성하는 컴포넌트.
  - `static`: CSS, JavaScript, 이미지 등 정적 파일.
  - `migrations`: `Goose`를 사용한 데이터베이스 스키마 마이그레이션 파일.
  - `query.sql`: `SQLC`가 사용할 SQL 쿼리.
- `internal`: 여러 프로젝트에서 공유하지만 외부로 노출되지 않는 서버 측 공통 패키지 (DB 연결, 미들웨어 등).
- `shared`: 여러 프로젝트에서 공유하는 프론트엔드 관련 공통 패키지 (공통 `views` 컴포넌트, `static` 파일 등).
- `pkg`: 외부 의존성이 없는 순수 유틸리티 함수 패키지.

## 코딩 스타일 가이드

- 파일명, 함수명, 변수명은 Go 표준 컨벤션을 따라줘.
- 로깅은 `slog` 패키지를 활용하며, 상황에 맞게 `DEBUG`, `INFO`, `WARN`, `ERROR` 레벨을 적절히 사용해. (로그 메시지는 한글로 명확하게 작성)
- 에러 핸들링은 Go 표준 방식(`if err != nil`)을 따라 명시적으로 처리해.
- `Gomponents`로 뷰를 작성할 때, 동적인 기능은 `hx-` 속성을 적극 활용하고, 클라이언트 측 상태 관리가 필요할 때만 `Alpine.js`를 사용해. JavaScript 코드는 별도 `.js` 파일로 분리해줘.

## HTTP/HTMX 응답 규칙

- 저장/수정/삭제 성공: 204 No Content. 본문 없이 성공을 명확히 표현하고 HTMX 스왑을 방지.
- 새 리소스 생성: 201 Created. 필요 시 `Location` 헤더로 리소스 위치 제공.
- 비동기 처리 접수: 202 Accepted. 예) 작업 큐에 등록만 하는 요청.
- 부분 갱신(HTML 조각): 200 OK + HTML 본문을 반환해 대상 영역을 갱신.
- 리다이렉션: `HX-Redirect` 헤더 설정 후 204 또는 200으로 종료.
- 오류 응답: 상황에 맞는 4xx/5xx와 한글 메시지를 명확히 반환.

참고: 200 OK + 빈 본문은 HTMX 기본 스왑으로 대상 영역을 비워버릴 수 있음. 바디가 없을 때는 204를 사용해 의도(스왑 없음)를 분명히 한다.

## 런타임 모드

- 개발 모드: GoVisual로 실행(`TransferEchoToGoVisualServerOnlyDev`), 정적 파일은 로컬 디스크 사용.
- 운영 모드: Echo 단독 실행, 정적 파일은 `embed.FS` 사용, Gzip 활성화.
- 요청 타임아웃: 1분, 요청당 바디 제한: 5MB, 레이트리미트: 초당 20회.

## 정적/임베드 자원

- 공통 정적: `/shared/static` → `shared/static/*`
- 프로젝트 정적: `/static` → `projects/{name}/static/*`
- PWA/서비스워커: `/manifest.json`, `/firebase-messaging-sw.js` 매핑.
- Dev: `os.DirFS`, Prod: `resources.EmbeddedFiles`(embed) 사용.

## 인증/권한

- 인증: Firebase ID 토큰을 `/create-session`에 전달 → `session_v2` 쿠키 저장(Lax, 운영은 Secure).
- 사용자 식별: `authutil.SessionUID(c)` 사용(없으면 에러 처리).
- 권한: Casbin(SQL 어댑터). `obj=c.Path()`, `act=METHOD`. 모델은 `model.conf`(embed), 정책은 DB 저장.

## 라우팅/핸들러 가이드

- 공개 라우트: 인덱스/로그인/프라이버시/리스트 조회 등.
- 보호 라우트: 저장/수정/삭제/검색/통계 등(세션 + 권한 필요).
- 바인딩/검증: `c.Bind(...)` + 최소한의 검증, 잘못된 입력은 400/422.
- 에러: `echo.NewHTTPError`로 4xx/5xx와 한글 메시지 반환.

## 테스트 가이드

- ❗ **중요**: CI 환경에는 데이터베이스가 없어. 반드시 Mock 기반의 순수 유닛 테스트만 작성해줘.
- 유닛 테스트는 원본 파일과 같은 경로에 `{파일}_test.go` 형식으로 작성해.

## 스키마 및 쿼리 수정

1.  **스키마 수정**: `./projects/{프로젝트명}/migrations/` 폴더에 `*.sql` 마이그레이션 파일을 추가해.
2.  **쿼리 수정**: `./projects/{프로젝트명}/query.sql` 파일을 수정해.
3.  **코드 생성**: 프로젝트 루트 디렉토리에서 `./task.sh sqlc:generate {프로젝트명}` 명령어를 실행해.

## 프로젝트 설명

- **homepage**: 여러 서비스들을 소개하고 진입점을 제공하는 포털 페이지.
  - **특이사항**: 이 프로젝트는 `BeerCSS` 대신 `TailwindCSS`를 사용해.
- **ai-study**: 특정 주제를 입력하면 AI가 관련된 세부 학습 주제 10가지를 제안하는 서비스.
- **deario**: 오늘의 일기를 작성하면 AI가 간단한 피드백으로 하루를 돌아볼 수 있게 도와주는 서비스.
- **portfolio**: 자산 포트폴리오 관리 서비스.
- **sample**: 새로운 기능이나 라이브러리 동작을 검증하기 위한 샘플 프로젝트.

## ⭐ 최종 확인 단계

- 수정 완료 후, 위에 명시된 모든 가이드를 준수했는지 다시 한번 확인해줘.
- 마지막으로, 프로젝트 루트 디렉토리에서 `./task.sh check`를 실행해서 **빌드, 테스트, 린트(linter) 검증**을 모두 진행해줘.
- `check` 과정에서 실패가 발생하면, 원인을 분석하여 수정한 후 **성공할 때까지 재시도**해줘.
- ❗ **주의**: `./task.sh check` 명령어는 여러 작업을 수행하므로 시간이 다소 걸릴 수 있어. 응답이 없다고 오류로 판단하지 말고, 충분히 기다린 후 결과를 확인해줘.
